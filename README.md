BROTEA FLORIN-ALEXANDRU, 324CA

Primul task, cel de adaugare bloc, se axeaza pe plasarea unui bloc intr-o locatie specificata, identificata prin coordonatele (x, y, z). Inainte de a efectua aceasta operatiune, am verificat daca coordonatele sunt valide, adica daca se incadreaza in limitele dimensiunilor chunk-ului. Daca validarea a avut succes, valoarea blocului a fost atribuita direct in matricea 3D. Aceasta functie asigura o utlizare mai eficienta a memoriei.
In final, am dat return chunk pentru a confirma validarea buna pentru adaugarea blocului.

La al doilea task, cel de umplere a paralelipipedului, am determinat mai intai coordonatele minime si maxime pe fiecare axa, realizand comparatii specifice operatiilor elementare de determinare a maximului dintre 2 numere, indiferent de ordinea in care au fost introduse punctele. Limitele chunk-ului au fost de asemenea luate in considerare, ajustand valorile astfel incat sa se evite accesarea zonelor nepermise. Pentru fiecare punct considerat ca apartine paralelipipedului, am utilizat trei bucle imbricate pentru a determina volumul dintr-un spatiu tridimensional. Prima bucla parcurge coordonatele de pe axa X, a doua bucla traverseaza valorile de pe axa Y pentru fiecare X, iar a treia bucla itereaza prin toate valorile de pe axa Z pentru fiecare pereche (X, Y). In cadrul acestei structuri, fiecare element al matricei 3D este accesat si actualizat cu valoarea specificata a blocului.

Intr-o maniera oarecum asemanatoare am apelat si pentru taskul al treilea, care cerea umplerea sferei. Mi-am definit pentru inceput un bounding box in functie de raza. Pentru fiecare punct din acesta, am calculat distanta fata de centrul sferei utilizand formula euclidiana. Daca distanta calculata este mai mica decat patratul razei sferei, atunci punctul respectiv este considerat ca fiind parte a sferei. Pentru toate punctele care se afla in interiorul sferei, am atribuit blocul specificat. Am folosit trei bucle imbricate pentru a itera prin toate punctele din bounding box si pentru a verifica fiecare punct in parte. In final, pentru a respecta conventiile cerute, am folosit aceleasi if-uri ca la finalul codului ce rezolva taskul 2.

Al patrulea task, cu invelisul in jurul unui bloc, il implementez verificand fiecare bloc din chunk, iar daca acesta este de tip target_block, analizez vecinii sai pentru a plasa blocuri de tip shell_block. Am realizat o copie a chunk-ului original pentru a evita suprascrierea directa si pentru a ma asigura ca modificarile facute nu afecteaza iteratia. Vecinatatile au fost determinate utilizand trei bucle imbricate care traverseaza toate pozitiile in jurul unui bloc tinta.

Pentru taskul 5, cel de umplere doar in planul xOz, am marcat pozitia curenta ca fiind procesata, atribuind blocul dorit la coordonatele respective. Am adaugat in stive coordonatele vecinilor din planul xOz (sus, jos, stanga, dreapta) care contin acelasi tip de bloc ca cel initial.
Continui iterativ acest proces pana cand toate pozitiile conectate din planul xOz sunt procesate. Apoi, am alocat dinamic eficient matricea folosind realloc, malloc si free.

La taskul 6, cel de umplere in spatiu, am verificat daca pozitia initiala este valida si daca se afla in limitele chunk-ului. In cazul in care coordonata era invalida sau blocul de la pozitia initiala nu corespundea blocului tinta, functia se oprea. Pentru fiecare pozitie buna si, ulterior, validata, se marcheaza pozitia curenta ca fiind vizitata, atribuind blocul dorit la coordonatele respective, se adauga coordonatele vecinilor acestei pozitii in stivele de procesare, dar numai daca acestea sunt in limitele chunk-ului si au acelasi tip de bloc ca pozitia initiala. Se continua iterativ acest proces pana cand toate pozitiile conectate sunt procesate. Practic, rezolvarea la acest task este o dezvoltare a rezolvarii taskului 5, care realiza procesul de umplere in spatiu bidimensional, si nu tridimensional ca acum. Tot la fel, am eliberat si memoria.

La taskul 7, de rotire in jurul axei Oy, am inceput prin alocarea dinamica a unui nou chunk, cu dimensiuni ajustate astfel incat latimea si adancimea originala sa fie interschimbate. Aceasta ajustare este necesara deoarece, prin rotire, ceea ce era initial adancime devine latime, iar ceea ce era latime devine adancime. Dupa alocarea memoriei pentru noul chunk, am parcurs matricea originala tridimensionala utilizand trei bucle imbricate. Pentru fiecare punct din chunk-ul initial, am calculat noile coordonate pe baza regulii de rotire: coordonata X devine adancimea initiala scazuta din dimensiunea originala minus 1 (pentru a ajusta inversarea indexarii), coordonata Z devine coordonata X originala, iar coordonata Y ramane neschimbata, deoarece axa Y este axa in jurul careia se efectueaza rotirea. Valorile din chunk-ul original sunt copiate in chunk-ul nou, conform acestor coordonate noi. La final, memoria asociata chunk-ului initial a fost eliberata folosind free.